package klik.util.image.decoding;

import javafx.scene.image.Image;
import javafx.scene.image.PixelWriter;
import javafx.scene.image.WritableImage;
import javafx.stage.Window;
import klik.util.execute.actor.Aborter;
import klik.look.Jar_utils;
import klik.util.log.Logger;
import nom.tam.fits.BasicHDU;
import nom.tam.fits.Fits;
import nom.tam.fits.ImageHDU;

import java.io.IOException;
import java.nio.file.Path;
import java.util.Optional;

//**********************************************************
public class FITS
//**********************************************************
{
    /*
    FITS
    (image format for scientists/astronomers)
    https://en.wikipedia.org/wiki/FITS
    https://imagej.net/libs/scifio
    is supported via:
    https://heasarc.gsfc.nasa.gov/docs/heasarc/fits/
    */

    //**********************************************************
    public static Optional<Image> load_FITS_image(Path original_image_file, Aborter aborter, Window owner, Logger logger)
    //**********************************************************
    {
        Fits fits = new Fits(original_image_file.toFile());

        BasicHDU<?> hdu = null;
        try {
            hdu = fits.readHDU();
        } catch (IOException e) {
            logger.log("" + e);
            return Optional.of(Jar_utils.get_broken_icon(300,owner,logger));
        }

        if (!(hdu instanceof ImageHDU)) {
            logger.log("no Image HDU");
            return Optional.of(Jar_utils.get_broken_icon(300,owner,logger));
        }

        ImageHDU imageHDU = (ImageHDU) hdu;

        if ( aborter.should_abort())
        {
            logger.log("FITS loading aborted");
            return Optional.of(Jar_utils.get_broken_icon(300,owner,logger));
        }
        // Retrieve the raw kernel (pixel array)
        Object kernel = imageHDU.getKernel();
        if ( kernel == null)
        {
            logger.log("no image data");
            return Optional.of(Jar_utils.get_broken_icon(300,owner,logger));
        }

        // we read the first 2 dimensions and convert to double[][]
        double[][] data;
        if (kernel instanceof double[][]) {
            data = (double[][]) kernel;
        }
        else if (kernel instanceof byte[][])
        {
            // Convert byte[][] to double[][]
            byte[][] f = (byte[][]) kernel;
            data = new double[f.length][f[0].length];
            for (int i = 0; i < f.length; i++) {
                for (int j = 0; j < f[0].length; j++) {
                    data[i][j] = f[i][j];
                }
            }
        }
        else if (kernel instanceof byte[][][])
        {
            // Convert byte[][][] to double[][]
            byte[][][] f = (byte[][][]) kernel;
            data = new double[f.length][f[0].length];
            for (int i = 0; i < f.length; i++) {
                for (int j = 0; j < f[0].length; j++) {
                    data[i][j] = f[i][j][0];
                }
            }
        }
        else if (kernel instanceof byte[][][][])
        {
            // Convert byte[][][][] to double[][]
            byte[][][][] f = (byte[][][][]) kernel;
            data = new double[f.length][f[0].length];
            for (int i = 0; i < f.length; i++) {
                for (int j = 0; j < f[0].length; j++) {
                    data[i][j] = f[i][j][0][0];
                }
            }
        }
        else if (kernel instanceof float[][])
        {
            // Convert float[][] to double[][]
            float[][] f = (float[][]) kernel;
            data = new double[f.length][f[0].length];
            for (int i = 0; i < f.length; i++) {
                for (int j = 0; j < f[0].length; j++) {
                    data[i][j] = f[i][j];
                }
            }
        }
        else if (kernel instanceof float[][][])
        {
            // Convert float[][][] to double[][]
            float[][][] f = (float[][][]) kernel;
            data = new double[f.length][f[0].length];
            for (int i = 0; i < f.length; i++) {
                for (int j = 0; j < f[0].length; j++) {
                    data[i][j] = f[i][j][0];
                }
            }
        }
        else if (kernel instanceof float[][][][])
        {
            // Convert float[][][][] to double[][]
            float[][][][] f = (float[][][][]) kernel;
            data = new double[f.length][f[0].length];
            for (int i = 0; i < f.length; i++) {
                for (int j = 0; j < f[0].length; j++) {
                    data[i][j] = f[i][j][0][0];
                }
            }
        }
        else if (kernel instanceof float[][][][][])
        {
            // Convert float[][][][][] to double[][]
            float[][][][][] f = (float[][][][][]) kernel;
            data = new double[f.length][f[0].length];
            for (int i = 0; i < f.length; i++) {
                for (int j = 0; j < f[0].length; j++) {
                    data[i][j] = f[i][j][0][0][0];
                }
            }
        }

        else if (kernel instanceof short[][])
        {
            // Convert short[][] to double[][]
            short[][] f = (short[][]) kernel;
            data = new double[f.length][f[0].length];
            for (int i = 0; i < f.length; i++) {
                for (int j = 0; j < f[0].length; j++) {
                    data[i][j] = f[i][j];
                }
            }
        }
        else if (kernel instanceof short[][][])
        {
            // Convert short[][][] to double[][]
            short[][][] f = (short[][][]) kernel;
            data = new double[f.length][f[0].length];
            for (int i = 0; i < f.length; i++) {
                for (int j = 0; j < f[0].length; j++) {
                    data[i][j] = f[i][j][0];
                }
            }
        }
        else if (kernel instanceof short[][][][])
        {
            // Convert short[][][][] to double[][]
            short[][][][] f = (short[][][][]) kernel;
            data = new double[f.length][f[0].length];
            for (int i = 0; i < f.length; i++) {
                for (int j = 0; j < f[0].length; j++) {
                    data[i][j] = f[i][j][0][0];
                }
            }
        }
        else if (kernel instanceof int[][])
        {
            // Convert int[][] to double[][]
            int[][] f = (int[][]) kernel;
            data = new double[f.length][f[0].length];
            for (int i = 0; i < f.length; i++) {
                for (int j = 0; j < f[0].length; j++) {
                    data[i][j] = f[i][j];
                }
            }
        }
        else if (kernel instanceof int[][][])
        {
            // Convert int[][][] to double[][]
            int[][][] f = (int[][][]) kernel;
            data = new double[f.length][f[0].length];
            for (int i = 0; i < f.length; i++) {
                for (int j = 0; j < f[0].length; j++) {
                    data[i][j] = f[i][j][0];
                }
            }
        }
        else if (kernel instanceof int[][][][])
        {
            // Convert int[][][][] to double[][]
            int[][][][] f = (int[][][][]) kernel;
            data = new double[f.length][f[0].length];
            for (int i = 0; i < f.length; i++) {
                for (int j = 0; j < f[0].length; j++) {
                    data[i][j] = f[i][j][0][0];
                }
            }
        }
        else
        {
            logger.log("Unsupported pixel type: " + kernel.getClass().getCanonicalName());
            return Optional.of(Jar_utils.get_broken_icon(300,owner,logger));
        }

        if ( aborter.should_abort())
        {
            logger.log("FITS loading aborted");
            return Optional.empty();
        }

        // convert to greyscale JavaFX image

        int height = data.length;
        int width = data[0].length;

        // Find min / max for scaling
        double min = Double.POSITIVE_INFINITY;
        double max = Double.NEGATIVE_INFINITY;
        for (double[] row : data) {
            for (double v : row) {
                if (v < min) min = v;
                if (v > max) max = v;
            }
        }
        if (min == max) { // flat image – avoid divide‑by‑zero
            min = 0;
            max = 1;
        }

        if ( aborter.should_abort())
        {
            logger.log("FITS loading aborted");
            return Optional.empty();
        }
        // Create writable image
        WritableImage image = new WritableImage(width, height);
        PixelWriter pw = image.getPixelWriter();

        // Scale to 0‑255 and write pixel by pixel
        for (int y = 0; y < height; y++) {
            double[] row = data[y];
            for (int x = 0; x < width; x++) {
                double v = row[x];
                // Linear mapping to 0‑255
                int gray = (int) ((v - min) / (max - min) * 255);
                if (gray < 0) gray = 0;
                if (gray > 255) gray = 255;
                int argb = (0xFF << 24) | (gray << 16) | (gray << 8) | gray;
                pw.setArgb(x, y, argb);
            }
            if ( aborter.should_abort())
            {
                logger.log("FITS loading aborted");
                return Optional.empty();
            }
        }
        return Optional.of(image);
    }
}
